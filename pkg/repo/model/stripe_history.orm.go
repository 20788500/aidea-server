package model

// !!! DO NOT EDIT THIS FILE

import (
	"context"
	"encoding/json"
	"github.com/iancoleman/strcase"
	"github.com/mylxsw/eloquent/query"
	"gopkg.in/guregu/null.v3"
	"time"
)

func init() {

}

// StripeHistoryN is a StripeHistory object, all fields are nullable
type StripeHistoryN struct {
	original           *stripeHistoryOriginal
	stripeHistoryModel *StripeHistoryModel

	Id             null.Int    `json:"id"`
	UserId         null.Int    `json:"user_id,omitempty"`
	PaymentId      null.String `json:"payment_id,omitempty"`
	ProductId      null.String `json:"product_id,omitempty"`
	CustomerId     null.String `json:"customer_id,omitempty"`
	Extra          null.String `json:"extra,omitempty"`
	ReceiptUrl     null.String `json:"receipt_url,omitempty"`
	Amount         null.Int    `json:"amount,omitempty"`
	AmountReceived null.Int    `json:"amount_received,omitempty"`
	Currency       null.String `json:"currency,omitempty"`
	Environment    null.String `json:"environment"`
	PaymentIntent  null.String `json:"payment_intent,omitempty"`
	Status         null.Int    `json:"status,omitempty"`
	PurchaseAt     null.Time   `json:"purchase_at"`
	Note           null.String `json:"note"`
	CreatedAt      null.Time
	UpdatedAt      null.Time
}

// As convert object to other type
// dst must be a pointer to struct
func (inst *StripeHistoryN) As(dst interface{}) error {
	return query.Copy(inst, dst)
}

// SetModel set model for StripeHistory
func (inst *StripeHistoryN) SetModel(stripeHistoryModel *StripeHistoryModel) {
	inst.stripeHistoryModel = stripeHistoryModel
}

// stripeHistoryOriginal is an object which stores original StripeHistory from database
type stripeHistoryOriginal struct {
	Id             null.Int
	UserId         null.Int
	PaymentId      null.String
	ProductId      null.String
	CustomerId     null.String
	Extra          null.String
	ReceiptUrl     null.String
	Amount         null.Int
	AmountReceived null.Int
	Currency       null.String
	Environment    null.String
	PaymentIntent  null.String
	Status         null.Int
	PurchaseAt     null.Time
	Note           null.String
	CreatedAt      null.Time
	UpdatedAt      null.Time
}

// Staled identify whether the object has been modified
func (inst *StripeHistoryN) Staled(onlyFields ...string) bool {
	if inst.original == nil {
		inst.original = &stripeHistoryOriginal{}
	}

	if len(onlyFields) == 0 {

		if inst.Id != inst.original.Id {
			return true
		}
		if inst.UserId != inst.original.UserId {
			return true
		}
		if inst.PaymentId != inst.original.PaymentId {
			return true
		}
		if inst.ProductId != inst.original.ProductId {
			return true
		}
		if inst.CustomerId != inst.original.CustomerId {
			return true
		}
		if inst.Extra != inst.original.Extra {
			return true
		}
		if inst.ReceiptUrl != inst.original.ReceiptUrl {
			return true
		}
		if inst.Amount != inst.original.Amount {
			return true
		}
		if inst.AmountReceived != inst.original.AmountReceived {
			return true
		}
		if inst.Currency != inst.original.Currency {
			return true
		}
		if inst.Environment != inst.original.Environment {
			return true
		}
		if inst.PaymentIntent != inst.original.PaymentIntent {
			return true
		}
		if inst.Status != inst.original.Status {
			return true
		}
		if inst.PurchaseAt != inst.original.PurchaseAt {
			return true
		}
		if inst.Note != inst.original.Note {
			return true
		}
		if inst.CreatedAt != inst.original.CreatedAt {
			return true
		}
		if inst.UpdatedAt != inst.original.UpdatedAt {
			return true
		}
	} else {
		for _, f := range onlyFields {
			switch strcase.ToSnake(f) {

			case "id":
				if inst.Id != inst.original.Id {
					return true
				}
			case "user_id":
				if inst.UserId != inst.original.UserId {
					return true
				}
			case "payment_id":
				if inst.PaymentId != inst.original.PaymentId {
					return true
				}
			case "product_id":
				if inst.ProductId != inst.original.ProductId {
					return true
				}
			case "customer_id":
				if inst.CustomerId != inst.original.CustomerId {
					return true
				}
			case "extra":
				if inst.Extra != inst.original.Extra {
					return true
				}
			case "receipt_url":
				if inst.ReceiptUrl != inst.original.ReceiptUrl {
					return true
				}
			case "amount":
				if inst.Amount != inst.original.Amount {
					return true
				}
			case "amount_received":
				if inst.AmountReceived != inst.original.AmountReceived {
					return true
				}
			case "currency":
				if inst.Currency != inst.original.Currency {
					return true
				}
			case "environment":
				if inst.Environment != inst.original.Environment {
					return true
				}
			case "payment_intent":
				if inst.PaymentIntent != inst.original.PaymentIntent {
					return true
				}
			case "status":
				if inst.Status != inst.original.Status {
					return true
				}
			case "purchase_at":
				if inst.PurchaseAt != inst.original.PurchaseAt {
					return true
				}
			case "note":
				if inst.Note != inst.original.Note {
					return true
				}
			case "created_at":
				if inst.CreatedAt != inst.original.CreatedAt {
					return true
				}
			case "updated_at":
				if inst.UpdatedAt != inst.original.UpdatedAt {
					return true
				}
			default:
			}
		}
	}

	return false
}

// StaledKV return all fields has been modified
func (inst *StripeHistoryN) StaledKV(onlyFields ...string) query.KV {
	kv := make(query.KV, 0)

	if inst.original == nil {
		inst.original = &stripeHistoryOriginal{}
	}

	if len(onlyFields) == 0 {

		if inst.Id != inst.original.Id {
			kv["id"] = inst.Id
		}
		if inst.UserId != inst.original.UserId {
			kv["user_id"] = inst.UserId
		}
		if inst.PaymentId != inst.original.PaymentId {
			kv["payment_id"] = inst.PaymentId
		}
		if inst.ProductId != inst.original.ProductId {
			kv["product_id"] = inst.ProductId
		}
		if inst.CustomerId != inst.original.CustomerId {
			kv["customer_id"] = inst.CustomerId
		}
		if inst.Extra != inst.original.Extra {
			kv["extra"] = inst.Extra
		}
		if inst.ReceiptUrl != inst.original.ReceiptUrl {
			kv["receipt_url"] = inst.ReceiptUrl
		}
		if inst.Amount != inst.original.Amount {
			kv["amount"] = inst.Amount
		}
		if inst.AmountReceived != inst.original.AmountReceived {
			kv["amount_received"] = inst.AmountReceived
		}
		if inst.Currency != inst.original.Currency {
			kv["currency"] = inst.Currency
		}
		if inst.Environment != inst.original.Environment {
			kv["environment"] = inst.Environment
		}
		if inst.PaymentIntent != inst.original.PaymentIntent {
			kv["payment_intent"] = inst.PaymentIntent
		}
		if inst.Status != inst.original.Status {
			kv["status"] = inst.Status
		}
		if inst.PurchaseAt != inst.original.PurchaseAt {
			kv["purchase_at"] = inst.PurchaseAt
		}
		if inst.Note != inst.original.Note {
			kv["note"] = inst.Note
		}
		if inst.CreatedAt != inst.original.CreatedAt {
			kv["created_at"] = inst.CreatedAt
		}
		if inst.UpdatedAt != inst.original.UpdatedAt {
			kv["updated_at"] = inst.UpdatedAt
		}
	} else {
		for _, f := range onlyFields {
			switch strcase.ToSnake(f) {

			case "id":
				if inst.Id != inst.original.Id {
					kv["id"] = inst.Id
				}
			case "user_id":
				if inst.UserId != inst.original.UserId {
					kv["user_id"] = inst.UserId
				}
			case "payment_id":
				if inst.PaymentId != inst.original.PaymentId {
					kv["payment_id"] = inst.PaymentId
				}
			case "product_id":
				if inst.ProductId != inst.original.ProductId {
					kv["product_id"] = inst.ProductId
				}
			case "customer_id":
				if inst.CustomerId != inst.original.CustomerId {
					kv["customer_id"] = inst.CustomerId
				}
			case "extra":
				if inst.Extra != inst.original.Extra {
					kv["extra"] = inst.Extra
				}
			case "receipt_url":
				if inst.ReceiptUrl != inst.original.ReceiptUrl {
					kv["receipt_url"] = inst.ReceiptUrl
				}
			case "amount":
				if inst.Amount != inst.original.Amount {
					kv["amount"] = inst.Amount
				}
			case "amount_received":
				if inst.AmountReceived != inst.original.AmountReceived {
					kv["amount_received"] = inst.AmountReceived
				}
			case "currency":
				if inst.Currency != inst.original.Currency {
					kv["currency"] = inst.Currency
				}
			case "environment":
				if inst.Environment != inst.original.Environment {
					kv["environment"] = inst.Environment
				}
			case "payment_intent":
				if inst.PaymentIntent != inst.original.PaymentIntent {
					kv["payment_intent"] = inst.PaymentIntent
				}
			case "status":
				if inst.Status != inst.original.Status {
					kv["status"] = inst.Status
				}
			case "purchase_at":
				if inst.PurchaseAt != inst.original.PurchaseAt {
					kv["purchase_at"] = inst.PurchaseAt
				}
			case "note":
				if inst.Note != inst.original.Note {
					kv["note"] = inst.Note
				}
			case "created_at":
				if inst.CreatedAt != inst.original.CreatedAt {
					kv["created_at"] = inst.CreatedAt
				}
			case "updated_at":
				if inst.UpdatedAt != inst.original.UpdatedAt {
					kv["updated_at"] = inst.UpdatedAt
				}
			default:
			}
		}
	}

	return kv
}

// Save create a new model or update it
func (inst *StripeHistoryN) Save(ctx context.Context, onlyFields ...string) error {
	if inst.stripeHistoryModel == nil {
		return query.ErrModelNotSet
	}

	id, _, err := inst.stripeHistoryModel.SaveOrUpdate(ctx, *inst, onlyFields...)
	if err != nil {
		return err
	}

	inst.Id = null.IntFrom(id)
	return nil
}

// Delete remove a stripe_history
func (inst *StripeHistoryN) Delete(ctx context.Context) error {
	if inst.stripeHistoryModel == nil {
		return query.ErrModelNotSet
	}

	_, err := inst.stripeHistoryModel.DeleteById(ctx, inst.Id.Int64)
	if err != nil {
		return err
	}

	return nil
}

// String convert instance to json string
func (inst *StripeHistoryN) String() string {
	rs, _ := json.Marshal(inst)
	return string(rs)
}

type stripeHistoryScope struct {
	name  string
	apply func(builder query.Condition)
}

var stripeHistoryGlobalScopes = make([]stripeHistoryScope, 0)
var stripeHistoryLocalScopes = make([]stripeHistoryScope, 0)

// AddGlobalScopeForStripeHistory assign a global scope to a model
func AddGlobalScopeForStripeHistory(name string, apply func(builder query.Condition)) {
	stripeHistoryGlobalScopes = append(stripeHistoryGlobalScopes, stripeHistoryScope{name: name, apply: apply})
}

// AddLocalScopeForStripeHistory assign a local scope to a model
func AddLocalScopeForStripeHistory(name string, apply func(builder query.Condition)) {
	stripeHistoryLocalScopes = append(stripeHistoryLocalScopes, stripeHistoryScope{name: name, apply: apply})
}

func (m *StripeHistoryModel) applyScope() query.Condition {
	scopeCond := query.ConditionBuilder()
	for _, g := range stripeHistoryGlobalScopes {
		if m.globalScopeEnabled(g.name) {
			g.apply(scopeCond)
		}
	}

	for _, s := range stripeHistoryLocalScopes {
		if m.localScopeEnabled(s.name) {
			s.apply(scopeCond)
		}
	}

	return scopeCond
}

func (m *StripeHistoryModel) localScopeEnabled(name string) bool {
	for _, n := range m.includeLocalScopes {
		if name == n {
			return true
		}
	}

	return false
}

func (m *StripeHistoryModel) globalScopeEnabled(name string) bool {
	for _, n := range m.excludeGlobalScopes {
		if name == n {
			return false
		}
	}

	return true
}

type StripeHistory struct {
	Id             int64     `json:"id"`
	UserId         int64     `json:"user_id,omitempty"`
	PaymentId      string    `json:"payment_id,omitempty"`
	ProductId      string    `json:"product_id,omitempty"`
	CustomerId     string    `json:"customer_id,omitempty"`
	Extra          string    `json:"extra,omitempty"`
	ReceiptUrl     string    `json:"receipt_url,omitempty"`
	Amount         int64     `json:"amount,omitempty"`
	AmountReceived int64     `json:"amount_received,omitempty"`
	Currency       string    `json:"currency,omitempty"`
	Environment    string    `json:"environment"`
	PaymentIntent  string    `json:"payment_intent,omitempty"`
	Status         int       `json:"status,omitempty"`
	PurchaseAt     time.Time `json:"purchase_at"`
	Note           string    `json:"note"`
	CreatedAt      time.Time
	UpdatedAt      time.Time
}

func (w StripeHistory) ToStripeHistoryN(allows ...string) StripeHistoryN {
	if len(allows) == 0 {
		return StripeHistoryN{

			Id:             null.IntFrom(int64(w.Id)),
			UserId:         null.IntFrom(int64(w.UserId)),
			PaymentId:      null.StringFrom(w.PaymentId),
			ProductId:      null.StringFrom(w.ProductId),
			CustomerId:     null.StringFrom(w.CustomerId),
			Extra:          null.StringFrom(w.Extra),
			ReceiptUrl:     null.StringFrom(w.ReceiptUrl),
			Amount:         null.IntFrom(int64(w.Amount)),
			AmountReceived: null.IntFrom(int64(w.AmountReceived)),
			Currency:       null.StringFrom(w.Currency),
			Environment:    null.StringFrom(w.Environment),
			PaymentIntent:  null.StringFrom(w.PaymentIntent),
			Status:         null.IntFrom(int64(w.Status)),
			PurchaseAt:     null.TimeFrom(w.PurchaseAt),
			Note:           null.StringFrom(w.Note),
			CreatedAt:      null.TimeFrom(w.CreatedAt),
			UpdatedAt:      null.TimeFrom(w.UpdatedAt),
		}
	}

	res := StripeHistoryN{}
	for _, al := range allows {
		switch strcase.ToSnake(al) {

		case "id":
			res.Id = null.IntFrom(int64(w.Id))
		case "user_id":
			res.UserId = null.IntFrom(int64(w.UserId))
		case "payment_id":
			res.PaymentId = null.StringFrom(w.PaymentId)
		case "product_id":
			res.ProductId = null.StringFrom(w.ProductId)
		case "customer_id":
			res.CustomerId = null.StringFrom(w.CustomerId)
		case "extra":
			res.Extra = null.StringFrom(w.Extra)
		case "receipt_url":
			res.ReceiptUrl = null.StringFrom(w.ReceiptUrl)
		case "amount":
			res.Amount = null.IntFrom(int64(w.Amount))
		case "amount_received":
			res.AmountReceived = null.IntFrom(int64(w.AmountReceived))
		case "currency":
			res.Currency = null.StringFrom(w.Currency)
		case "environment":
			res.Environment = null.StringFrom(w.Environment)
		case "payment_intent":
			res.PaymentIntent = null.StringFrom(w.PaymentIntent)
		case "status":
			res.Status = null.IntFrom(int64(w.Status))
		case "purchase_at":
			res.PurchaseAt = null.TimeFrom(w.PurchaseAt)
		case "note":
			res.Note = null.StringFrom(w.Note)
		case "created_at":
			res.CreatedAt = null.TimeFrom(w.CreatedAt)
		case "updated_at":
			res.UpdatedAt = null.TimeFrom(w.UpdatedAt)
		default:
		}
	}

	return res
}

// As convert object to other type
// dst must be a pointer to struct
func (w StripeHistory) As(dst interface{}) error {
	return query.Copy(w, dst)
}

func (w *StripeHistoryN) ToStripeHistory() StripeHistory {
	return StripeHistory{

		Id:             w.Id.Int64,
		UserId:         w.UserId.Int64,
		PaymentId:      w.PaymentId.String,
		ProductId:      w.ProductId.String,
		CustomerId:     w.CustomerId.String,
		Extra:          w.Extra.String,
		ReceiptUrl:     w.ReceiptUrl.String,
		Amount:         w.Amount.Int64,
		AmountReceived: w.AmountReceived.Int64,
		Currency:       w.Currency.String,
		Environment:    w.Environment.String,
		PaymentIntent:  w.PaymentIntent.String,
		Status:         int(w.Status.Int64),
		PurchaseAt:     w.PurchaseAt.Time,
		Note:           w.Note.String,
		CreatedAt:      w.CreatedAt.Time,
		UpdatedAt:      w.UpdatedAt.Time,
	}
}

// StripeHistoryModel is a model which encapsulates the operations of the object
type StripeHistoryModel struct {
	db        *query.DatabaseWrap
	tableName string

	excludeGlobalScopes []string
	includeLocalScopes  []string

	query query.SQLBuilder
}

var stripeHistoryTableName = "stripe_history"

// StripeHistoryTable return table name for StripeHistory
func StripeHistoryTable() string {
	return stripeHistoryTableName
}

const (
	FieldStripeHistoryId             = "id"
	FieldStripeHistoryUserId         = "user_id"
	FieldStripeHistoryPaymentId      = "payment_id"
	FieldStripeHistoryProductId      = "product_id"
	FieldStripeHistoryCustomerId     = "customer_id"
	FieldStripeHistoryExtra          = "extra"
	FieldStripeHistoryReceiptUrl     = "receipt_url"
	FieldStripeHistoryAmount         = "amount"
	FieldStripeHistoryAmountReceived = "amount_received"
	FieldStripeHistoryCurrency       = "currency"
	FieldStripeHistoryEnvironment    = "environment"
	FieldStripeHistoryPaymentIntent  = "payment_intent"
	FieldStripeHistoryStatus         = "status"
	FieldStripeHistoryPurchaseAt     = "purchase_at"
	FieldStripeHistoryNote           = "note"
	FieldStripeHistoryCreatedAt      = "created_at"
	FieldStripeHistoryUpdatedAt      = "updated_at"
)

// StripeHistoryFields return all fields in StripeHistory model
func StripeHistoryFields() []string {
	return []string{
		"id",
		"user_id",
		"payment_id",
		"product_id",
		"customer_id",
		"extra",
		"receipt_url",
		"amount",
		"amount_received",
		"currency",
		"environment",
		"payment_intent",
		"status",
		"purchase_at",
		"note",
		"created_at",
		"updated_at",
	}
}

func SetStripeHistoryTable(tableName string) {
	stripeHistoryTableName = tableName
}

// NewStripeHistoryModel create a StripeHistoryModel
func NewStripeHistoryModel(db query.Database) *StripeHistoryModel {
	return &StripeHistoryModel{
		db:                  query.NewDatabaseWrap(db),
		tableName:           stripeHistoryTableName,
		excludeGlobalScopes: make([]string, 0),
		includeLocalScopes:  make([]string, 0),
		query:               query.Builder(),
	}
}

// GetDB return database instance
func (m *StripeHistoryModel) GetDB() query.Database {
	return m.db.GetDB()
}

func (m *StripeHistoryModel) clone() *StripeHistoryModel {
	return &StripeHistoryModel{
		db:                  m.db,
		tableName:           m.tableName,
		excludeGlobalScopes: append([]string{}, m.excludeGlobalScopes...),
		includeLocalScopes:  append([]string{}, m.includeLocalScopes...),
		query:               m.query,
	}
}

// WithoutGlobalScopes remove a global scope for given query
func (m *StripeHistoryModel) WithoutGlobalScopes(names ...string) *StripeHistoryModel {
	mc := m.clone()
	mc.excludeGlobalScopes = append(mc.excludeGlobalScopes, names...)

	return mc
}

// WithLocalScopes add a local scope for given query
func (m *StripeHistoryModel) WithLocalScopes(names ...string) *StripeHistoryModel {
	mc := m.clone()
	mc.includeLocalScopes = append(mc.includeLocalScopes, names...)

	return mc
}

// Condition add query builder to model
func (m *StripeHistoryModel) Condition(builder query.SQLBuilder) *StripeHistoryModel {
	mm := m.clone()
	mm.query = mm.query.Merge(builder)

	return mm
}

// Find retrieve a model by its primary key
func (m *StripeHistoryModel) Find(ctx context.Context, id int64) (*StripeHistoryN, error) {
	return m.First(ctx, m.query.Where("id", "=", id))
}

// Exists return whether the records exists for a given query
func (m *StripeHistoryModel) Exists(ctx context.Context, builders ...query.SQLBuilder) (bool, error) {
	count, err := m.Count(ctx, builders...)
	return count > 0, err
}

// Count return model count for a given query
func (m *StripeHistoryModel) Count(ctx context.Context, builders ...query.SQLBuilder) (int64, error) {
	sqlStr, params := m.query.
		Merge(builders...).
		Table(m.tableName).
		AppendCondition(m.applyScope()).
		ResolveCount()

	rows, err := m.db.QueryContext(ctx, sqlStr, params...)
	if err != nil {
		return 0, err
	}

	defer rows.Close()

	rows.Next()
	var res int64
	if err := rows.Scan(&res); err != nil {
		return 0, err
	}

	return res, nil
}

func (m *StripeHistoryModel) Paginate(ctx context.Context, page int64, perPage int64, builders ...query.SQLBuilder) ([]StripeHistoryN, query.PaginateMeta, error) {
	if page <= 0 {
		page = 1
	}

	if perPage <= 0 {
		perPage = 15
	}

	meta := query.PaginateMeta{
		PerPage: perPage,
		Page:    page,
	}

	count, err := m.Count(ctx, builders...)
	if err != nil {
		return nil, meta, err
	}

	meta.Total = count
	meta.LastPage = count / perPage
	if count%perPage != 0 {
		meta.LastPage += 1
	}

	res, err := m.Get(ctx, append([]query.SQLBuilder{query.Builder().Limit(perPage).Offset((page - 1) * perPage)}, builders...)...)
	if err != nil {
		return res, meta, err
	}

	return res, meta, nil
}

// Get retrieve all results for given query
func (m *StripeHistoryModel) Get(ctx context.Context, builders ...query.SQLBuilder) ([]StripeHistoryN, error) {
	b := m.query.Merge(builders...).Table(m.tableName).AppendCondition(m.applyScope())
	if len(b.GetFields()) == 0 {
		b = b.Select(
			"id",
			"user_id",
			"payment_id",
			"product_id",
			"customer_id",
			"extra",
			"receipt_url",
			"amount",
			"amount_received",
			"currency",
			"environment",
			"payment_intent",
			"status",
			"purchase_at",
			"note",
			"created_at",
			"updated_at",
		)
	}

	fields := b.GetFields()
	selectFields := make([]query.Expr, 0)

	for _, f := range fields {
		switch strcase.ToSnake(f.Value) {

		case "id":
			selectFields = append(selectFields, f)
		case "user_id":
			selectFields = append(selectFields, f)
		case "payment_id":
			selectFields = append(selectFields, f)
		case "product_id":
			selectFields = append(selectFields, f)
		case "customer_id":
			selectFields = append(selectFields, f)
		case "extra":
			selectFields = append(selectFields, f)
		case "receipt_url":
			selectFields = append(selectFields, f)
		case "amount":
			selectFields = append(selectFields, f)
		case "amount_received":
			selectFields = append(selectFields, f)
		case "currency":
			selectFields = append(selectFields, f)
		case "environment":
			selectFields = append(selectFields, f)
		case "payment_intent":
			selectFields = append(selectFields, f)
		case "status":
			selectFields = append(selectFields, f)
		case "purchase_at":
			selectFields = append(selectFields, f)
		case "note":
			selectFields = append(selectFields, f)
		case "created_at":
			selectFields = append(selectFields, f)
		case "updated_at":
			selectFields = append(selectFields, f)
		}
	}

	var createScanVar = func(fields []query.Expr) (*StripeHistoryN, []interface{}) {
		var stripeHistoryVar StripeHistoryN
		scanFields := make([]interface{}, 0)

		for _, f := range fields {
			switch strcase.ToSnake(f.Value) {

			case "id":
				scanFields = append(scanFields, &stripeHistoryVar.Id)
			case "user_id":
				scanFields = append(scanFields, &stripeHistoryVar.UserId)
			case "payment_id":
				scanFields = append(scanFields, &stripeHistoryVar.PaymentId)
			case "product_id":
				scanFields = append(scanFields, &stripeHistoryVar.ProductId)
			case "customer_id":
				scanFields = append(scanFields, &stripeHistoryVar.CustomerId)
			case "extra":
				scanFields = append(scanFields, &stripeHistoryVar.Extra)
			case "receipt_url":
				scanFields = append(scanFields, &stripeHistoryVar.ReceiptUrl)
			case "amount":
				scanFields = append(scanFields, &stripeHistoryVar.Amount)
			case "amount_received":
				scanFields = append(scanFields, &stripeHistoryVar.AmountReceived)
			case "currency":
				scanFields = append(scanFields, &stripeHistoryVar.Currency)
			case "environment":
				scanFields = append(scanFields, &stripeHistoryVar.Environment)
			case "payment_intent":
				scanFields = append(scanFields, &stripeHistoryVar.PaymentIntent)
			case "status":
				scanFields = append(scanFields, &stripeHistoryVar.Status)
			case "purchase_at":
				scanFields = append(scanFields, &stripeHistoryVar.PurchaseAt)
			case "note":
				scanFields = append(scanFields, &stripeHistoryVar.Note)
			case "created_at":
				scanFields = append(scanFields, &stripeHistoryVar.CreatedAt)
			case "updated_at":
				scanFields = append(scanFields, &stripeHistoryVar.UpdatedAt)
			}
		}

		return &stripeHistoryVar, scanFields
	}

	sqlStr, params := b.Fields(selectFields...).ResolveQuery()

	rows, err := m.db.QueryContext(ctx, sqlStr, params...)
	if err != nil {
		return nil, err
	}

	defer rows.Close()

	stripeHistorys := make([]StripeHistoryN, 0)
	for rows.Next() {
		stripeHistoryReal, scanFields := createScanVar(fields)
		if err := rows.Scan(scanFields...); err != nil {
			return nil, err
		}

		stripeHistoryReal.original = &stripeHistoryOriginal{}
		_ = query.Copy(stripeHistoryReal, stripeHistoryReal.original)

		stripeHistoryReal.SetModel(m)
		stripeHistorys = append(stripeHistorys, *stripeHistoryReal)
	}

	return stripeHistorys, nil
}

// First return first result for given query
func (m *StripeHistoryModel) First(ctx context.Context, builders ...query.SQLBuilder) (*StripeHistoryN, error) {
	res, err := m.Get(ctx, append(builders, query.Builder().Limit(1))...)
	if err != nil {
		return nil, err
	}

	if len(res) == 0 {
		return nil, query.ErrNoResult
	}

	return &res[0], nil
}

// Create save a new stripe_history to database
func (m *StripeHistoryModel) Create(ctx context.Context, kv query.KV) (int64, error) {

	if _, ok := kv["created_at"]; !ok {
		kv["created_at"] = time.Now()
	}

	if _, ok := kv["updated_at"]; !ok {
		kv["updated_at"] = time.Now()
	}

	sqlStr, params := m.query.Table(m.tableName).ResolveInsert(kv)

	res, err := m.db.ExecContext(ctx, sqlStr, params...)
	if err != nil {
		return 0, err
	}

	return res.LastInsertId()
}

// SaveAll save all stripe_historys to database
func (m *StripeHistoryModel) SaveAll(ctx context.Context, stripeHistorys []StripeHistoryN) ([]int64, error) {
	ids := make([]int64, 0)
	for _, stripeHistory := range stripeHistorys {
		id, err := m.Save(ctx, stripeHistory)
		if err != nil {
			return ids, err
		}

		ids = append(ids, id)
	}

	return ids, nil
}

// Save save a stripe_history to database
func (m *StripeHistoryModel) Save(ctx context.Context, stripeHistory StripeHistoryN, onlyFields ...string) (int64, error) {
	return m.Create(ctx, stripeHistory.StaledKV(onlyFields...))
}

// SaveOrUpdate save a new stripe_history or update it when it has a id > 0
func (m *StripeHistoryModel) SaveOrUpdate(ctx context.Context, stripeHistory StripeHistoryN, onlyFields ...string) (id int64, updated bool, err error) {
	if stripeHistory.Id.Int64 > 0 {
		_, _err := m.UpdateById(ctx, stripeHistory.Id.Int64, stripeHistory, onlyFields...)
		return stripeHistory.Id.Int64, true, _err
	}

	_id, _err := m.Save(ctx, stripeHistory, onlyFields...)
	return _id, false, _err
}

// UpdateFields update kv for a given query
func (m *StripeHistoryModel) UpdateFields(ctx context.Context, kv query.KV, builders ...query.SQLBuilder) (int64, error) {
	if len(kv) == 0 {
		return 0, nil
	}

	kv["updated_at"] = time.Now()

	sqlStr, params := m.query.Merge(builders...).AppendCondition(m.applyScope()).
		Table(m.tableName).
		ResolveUpdate(kv)

	res, err := m.db.ExecContext(ctx, sqlStr, params...)
	if err != nil {
		return 0, err
	}

	return res.RowsAffected()
}

// Update update a model for given query
func (m *StripeHistoryModel) Update(ctx context.Context, builder query.SQLBuilder, stripeHistory StripeHistoryN, onlyFields ...string) (int64, error) {
	return m.UpdateFields(ctx, stripeHistory.StaledKV(onlyFields...), builder)
}

// UpdateById update a model by id
func (m *StripeHistoryModel) UpdateById(ctx context.Context, id int64, stripeHistory StripeHistoryN, onlyFields ...string) (int64, error) {
	return m.Condition(query.Builder().Where("id", "=", id)).UpdateFields(ctx, stripeHistory.StaledKV(onlyFields...))
}

// Delete remove a model
func (m *StripeHistoryModel) Delete(ctx context.Context, builders ...query.SQLBuilder) (int64, error) {

	sqlStr, params := m.query.Merge(builders...).AppendCondition(m.applyScope()).Table(m.tableName).ResolveDelete()

	res, err := m.db.ExecContext(ctx, sqlStr, params...)
	if err != nil {
		return 0, err
	}

	return res.RowsAffected()

}

// DeleteById remove a model by id
func (m *StripeHistoryModel) DeleteById(ctx context.Context, id int64) (int64, error) {
	return m.Condition(query.Builder().Where("id", "=", id)).Delete(ctx)
}
